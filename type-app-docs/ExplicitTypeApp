Two big parts:

1. modifying the parser/lexer to have new syntax

2. modifying core to accept the modifications


in both phases:
1. Write up test cases, and attempt to pass all of them by the end of the time.

If in the event that I cannot get everything done:

1. important to document problems that I faced/am facing, especially if I am not
able to finish some part(s). 

2. additional part of the problem: how do I convince other people that I have 
solved it? Explain every choice that I make. -> KEEP A GOOD RECORD of what goes
on (including design decisions - why I chose X syntax over Y, for example).
Some more tips:

a. If I have finished the parser but not core, then I can ask for advice (on the 
ghc wiki) on what syntax to use (and have responses to heated arguments about 
syntax, on why some choices work versus other. will need data to argue points).	

Some useful emacs commands:
M-g M-n: goes to the first error or grep hit in compiler mode
C-c C-c: compile ghc (quickly)


Compiler process 3 stages:
1. Compile "Stage 1" of the compiler (barebones).
2. Stage 1 compiler is used to build all the interfaces (which change depending
on version of GHC).
3. After the libraries are built, we use the stage 1 compiler to go back, and 
compile the stage 2 compiler (bootstrapped compiler that has all features).
4. Optional: Though not used in practice, you could also build stage 3. 
it is used in code generation which I am not dealing with.

Can build stage3 by cding into the ghc subdirectory and running "make stage=2"

 -use ido-mode for awesome file opening
 - To incorporate changes to base in type-app:
  make sure all changes are committed and pushed to personal fork
 - git checkout master
 - ./sync-all pull
 - git checkout type-app
 - git merge master

should do that. May need to look over git stuff.
Also, have git manage